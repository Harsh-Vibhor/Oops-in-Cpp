There are four pillars of OOP ğŸ›ï¸

1) Encapsulation
One of them is Encapsulation.

ğŸ”¹ Encapsulation means wrapping data members (variables) and methods (functions) together into a single unit called a class ğŸ“¦.

It is mainly used to achieve data hiding ğŸ”’.

ğŸ‘‰ In simple words:
Encapsulation decides what data should be visible and what data should be hidden from the outside world.

Understanding with a real-life example ğŸ¦

Think of a banking system.

An account has:

Account ID

Username

Password

Balance

Now, as a user:

âœ… You can see account ID and username

âŒ You should NOT directly access password and balance

So what do we do? ğŸ¤”
We keep password and balance as private ğŸ”’
This prevents them from being accessed directly from outside the class.

If needed, we provide public methods (like checkBalance() or deposit()) to access or modify them safely ğŸ›¡ï¸.

This way:

Data stays secure

Direct misuse is prevented

Access is controlled


2) Inheritance
ğŸ§¬ Inheritance in C++

Inheritance means when the properties (data) and methods (functions) of a parent/base class are passed to a child/derived class.

ğŸ“Œ Main benefit:
â™»ï¸ Code reusability â€“ we donâ€™t have to write the same code again.

ğŸ” Order of Constructor & Destructor Calls

ğŸ— Constructor Call Order:
Parent class constructor â†’ Child class constructor

ğŸ§¹ Destructor Call Order:
Child class destructor â†’ Parent class destructor

Why?
Because the child depends on the parent, so the parent must be ready first, and cleaned last.

ğŸ” Modes of Inheritance

There are three modes of inheritance:

ğŸŒ Public

Public members of parent stay public in child

ğŸ›¡ Protected

Public & protected members become protected in child

ğŸ”’ Private

Public & protected members become private in child

These modes control how accessible the inherited members are.

ğŸ— Types of Inheritance

1ï¸âƒ£ Single Inheritance
One parent â†’ One child
Simple and common.

2ï¸âƒ£ Multilevel Inheritance
Parent â†’ Child â†’ Grandchild
Inheritance happens at multiple levels.

3ï¸âƒ£ Multiple Inheritance
One child inherits from multiple parents.

4ï¸âƒ£ Hierarchical Inheritance
One parent â†’ Multiple children.

5ï¸âƒ£ Hybrid Inheritance
Combination of two or more types of inheritance.

âš¡ Quick Summary

Inheritance = reusing parent class features ğŸ§¬

Saves time & code â™»ï¸

Constructor: Parent â†’ Child

Destructor: Child â†’ Parent

5 main types of inheritance


3) Polymorphism
ğŸ” Polymorphism in C++

Polymorphism means the ability of an object or function to behave in different ways depending on the situation.

In simple words:
â¡ï¸ Same name, different behavior.

ğŸ§  Simple Example

If a class has:

One constructor with parameters

One constructor without parameters

Then we can create different objects using different constructors.
This is an example of polymorphism.

ğŸ“Œ Types of Polymorphism

There are two types:

1ï¸âƒ£ Compile-Time Polymorphism
2ï¸âƒ£ Run-Time Polymorphism

âš™ Compile-Time Polymorphism

Here, the decision of which function to run is made at compile time ğŸ› ï¸.

Examples:

Constructor Overloading

Function Overloading

Operator Overloading

ğŸ“Œ Function Overloading means:
Same function name, but different parameters.

Example idea:
add(int a, int b)
add(int a, int b, int c)

â± Run-Time Polymorphism

Here, the decision of which function to run is made at run time â³.

Examples:

Function Overriding

Virtual Functions

ğŸ“Œ Function Overriding means:
Parent and child classes have the same function name, but the child provides a different implementation.

ğŸ§¬ Virtual Functions

A virtual function is a function:

Declared in the base (parent) class

Re-defined in the derived (child) class

Called based on the object type at runtime

Key points:

Uses the virtual keyword

Supports run-time polymorphism

Decision is made during program execution

Enables dynamic binding


4) Abstraction
ğŸ­ Abstraction in C++

Abstraction means:
ğŸ‘‰ Hiding unnecessary details
ğŸ‘‰ Showing only what is important

In simple words:
The user sees what to do, not how it is done.

Ways to Achieve Abstraction

1ï¸âƒ£ Using Access Specifiers

private â†’ hide internal details ğŸ”’

public â†’ show required features ğŸŒ

2ï¸âƒ£ Using Abstract Classes

ğŸ§± Abstract Class

An abstract class is a base class that:

Cannot be used to create objects âŒ

Is meant to be inherited by other classes

Contains pure virtual functions

âš™ Pure Virtual Function

A pure virtual function is a virtual function set to = 0.

It means:

The base class forces the child class to implement it

No object of the base class can be created

Example idea:
virtual void show() = 0;

ğŸ“Œ Static Keyword

ğŸ”¹ Static Variable inside a Function

Created only once

Keeps its value between function calls

Exists for the entire program life

ğŸ”¹ Static Variable inside a Class

Shared by all objects

Only one copy exists

Not created separately for each object

ğŸ¤ Friend Keyword in C++

The friend keyword allows another class or function to access the private and protected members of a class.

Normally:

Private data = hidden ğŸ”’

Protected data = limited access

But with friend:

Access is granted specially ğŸ›‚

Why Use Friend?

Sometimes two classes/functions:

Work very closely

Need to share internal data

So we use friend to allow controlled access.

Key Points about Friend

Friend is not a member of the class

It can access private + protected data

Friendship is not mutual

Friendship is not inherited

Simple Example Idea ğŸ§ 

If:

Class A has private data

Function B needs to access it

Then:

We make Function B a friend of Class A

Now Function B can access Aâ€™s private data.

âš¡ Quick Summary

Abstraction = show important, hide details ğŸ­

Abstract class = cannot create objects ğŸ§±

Pure virtual function = must be implemented âš™

Static = shared or lifetime-long â™»ï¸

Friend = special access to private data ğŸ¤
